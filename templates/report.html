<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">

<title>Project assignment results</title>
<meta name="description" content="Project assignment results">
<meta name="author" content="Automatic results generator">

<link href="report.css" rel="stylesheet" type="text/css" >
<script type="text/javascript" src="sorttable.js" ></script>
<script type="text/javascript" src="jquery-2.1.1.min.js" ></script>
<script type="text/javascript" src="jquery.sparkline.min.js" ></script>
<script type="text/javascript" src="jquery.fixedheadertable.min.js"></script>
<script type="text/javascript">
/* <![CDATA[ */
$(function() { $('.bar').sparkline('html', {type: 'bar'});
               /*$('.selectionmatrix').fixedHeaderTable({footer: false, 
                                                       cloneHeadToFoot: false, 
                                                       fixedColumn: true }); */
              });
/* ]]> */
</script>
</head>
<body>
<h1>Selections</h1>
<p>Report generated on {{ datetime.datetime.now().strftime('%c') }}</p>

<table class='selectionmatrix'>
<colgroup class='names'/>

{% for l in lecturers %}
  <colgroup span={{c[l]}} class='lect' id='{{'col_'+l}}'/>
{% endfor %}
<thead>
<tr><th/>{% for l in lecturers %}<th colspan={{c[l]}}>{{l}}{% endfor %}</tr>
<tr>
  <th>Project</th>
  {% for p in projects %}
  <th class=sel{{ p in selected }}
      title='{{'%s (%s)' % (','.join(studentsbyproject.get(p, [])),
                            projectdescriptions.get(p, ''))}}'>
      {{Project(p).number}}
  </th>
  {% endfor %}
</tr>
<tr><td>Min</td>{% for p in projects %} <td>{{minperproject[p]}}</td> {% endfor %}</tr>
<tr><td>Students</td>{% for p in projects %} <td>{{nstudentsbyproject[p]}}</td> {% endfor %}</tr>
<tr><td>Max</td>{% for p in projects %} <td>{{maxperproject[p]}}</td> {% endfor %}</tr>
</thead>

<tbody>
{# Translation has happened up to here
for s in students:
    n = studentnames[s]
    outfile.write('<tr><th class="names" title="%s - %s">%s</th>' % (s, projectsbystudent[s], n))
    for p in projects:
        key = (s,p)
        if choices[key] == '.':
            tdstyle = 'unselected'
        elif choices[key] == 'V':
            tdstyle = 'veto'
        elif choices[key] == 'P':
            tdstyle = 'preassigned'
        elif int(choices[key]) <= 5:
            tdstyle = 'good'
        elif int(choices[key]) > 7:
            tdstyle = 'bad'
        else:
            tdstyle = 'selected'
            
        if assignments.get(key, '0') == '1':
            tdstyle += 'assigned'
        else:
            tdstyle += 'unassigned'
            
        outfile.write('<td class="%s" title="%s - %s">%s</td>' % (tdstyle, n, p, choices[(s, p)]))
    outfile.write("</tr>\n")
outfile.write("</tbody>")
outfile.write("</table>")


flatmarks = [float(marks[s]) for s in students if s in marks]
classavg = mean(flatmarks)
def markbar(m):
    return str(qt.tag('span', "%s" % ','.join(["%2.1f" % (i-classavg) for i in m]), {'class': 'bar'}))

# About the statistics

section = [qt.h1("Statistics with marks"),
           qt.p("Class average: %2.1f" % classavg),
           qt.p("The bar charts indicate student marks minus class average -- red below class avg and blue above."),
           qt.p("For reference, the whole class looks like this: " + markbar(sorted(flatmarks))),
           qt.p("You can click on the headings to sort the tables.")]

outfile.writelines(map(str, section))

# Assignment histogram
# ======================================================================

outfile.write(str(qt.h2("Assignment breakdown")) + '\n')
outfile.write("<table>\n")
outfile.write(str(qt.tr([qt.th('Choice'), qt.th('N'), qt.th('Marks')])))
choicesbystudent = dict([(s, choices[(s, projectsbystudent[s])]) for s in students])
for choice in ['P'] + list(range(1, 11)) + ['.']:
    m = sorted([float(marks[s]) for s in students
                if choicesbystudent[s] == str(choice)])
    outfile.write(str(qt.tr([qt.td(str(choice)),
                             qt.td(len(m)),
                             qt.td(markbar(m))])))
outfile.write("</table>")
    

# Mark summary per lecturer
# ======================================================================
outfile.write(str(qt.h2("Statistics per lecturer")))
outfile.write("\n<table class='sortable'>\n")
outfile.write(str(qt.tr(qt.th(h) for h in ('Lecturer', 'Avg Mark', 'Breakdown', 'Number', 'Vetos', 'Pre', 'Popularity', 'Students'))))


def popscore(f):
    return 1/f if f > 0 else 1

for l in lecturers:
    m = sorted([float(marks[s]) for s in studentsbylecturer[l]])
    markavg = mean(m)
    msparkline = markbar(m)
    vetos = [i for i in choicesbylecturer[l] if i == 'V']
    nvetos = len(vetos)
    projectsbylecturer = [p for p in projects if Project(p).lecturer == l]
    nprojects = len(projectsbylecturer)
    preassignments = sum(1 for key in choices 
                           if choices[key] == 'P' and key[1] in projectsbylecturer)
    nassigned = nprojects - preassignments
    if nassigned > 0:
        popularity = sum([popscore(float(i)) 
                          for i in choicesbylecturer[l] 
                          if valid(i)])/float(nassigned)*10
    else:
        popularity = 0 
    data = [qt.td(l),
            qt.td('%2.1f' % markavg),
            qt.td(msparkline),
            qt.td(len(m)),
            qt.td('%2.1f' % (float(nvetos)/nprojects)),
            qt.td(preassignments),
            qt.td('%2.1f' % (popularity))]

    photos = []
    for s in studentsbylecturer[l]:
        p = projectsbystudent[s]
        title = ' '.join([studentnames[s], p, choices[(s,p)],
                          projectdescriptions[p]])
        photos.append(qt.tag('img', [], {'src': photopath(s),
                                         'alt': studentnames[s],
                                         'title': title,
                                         'width': '40'}))
    data.append(qt.td(photos))
    outfile.write(str(qt.tr(data)))
    
outfile.write("</table>\n")

# Per project
# ======================================================================
outfile.writelines([str(qt.h2('Statistics per project')),
                    str(qt.p("Here, the bar charts are for all the students who selected the project.")),
                    "<table class='sortable'>"])

breakdownvalues = ['P'] + [str(i) for i in range(1, 11)] + ['V']
row = [qt.th(e) for e in ['Project','Popularity', 'Marks', 'Breakdown'] \
                         + breakdownvalues + ['Total', 'Title']]
outfile.write(str(qt.tr(row)))
for p in projects:
    popularity = sum(popscore(float(choices[(s, p)])) for s in students if choices[(s,p)].isdigit())
    data = [qt.td(p), qt.td('%2.1f' % (popularity))]
    thesemarks = sorted(float(marks[s]) for s in students if choices[(s,p)].isdigit())
    data += [qt.td("%2.1f" % (mean(thesemarks))),
             qt.td(markbar(thesemarks))]
    data += [qt.td(sum([choices[(s, p)]==str(i) for s in students])) for i in breakdownvalues]
    data.append(qt.td(len(thesemarks)))
    data.append(qt.td(projectdescriptions[p]))
    outfile.write(str(qt.tr(data)))
                 
outfile.write("</table>\n")

# ======================================================================
outfile.writelines([str(qt.h2('Student satisfaction')),
                    str(qt.p('Who got their first choice, what were their marks, who got bad choices?')),
                   "<table class='sortable'>",
                   str(qt.tr(qt.th(k) for k in ('Number', 'Name', 'Mark', 'Choice', 'Project')))])
for s in students:
    p = projectsbystudent[s]
    outfile.writelines(str(qt.tr(qt.td(k) for k in (s, studentnames[s], "%2.1f" % float(marks[s]), choices[(s, p)], p))))
outfile.write("</table>\n")

# ======================================================================
outfile.writelines([str(qt.h2('Open projects')),
                    str(qt.p('Which projects can still be assigned without violating constraints'))])

outfile.write('<table>\n')
outfile.write(str(qt.tr([qt.th('Project'), qt.th('Description')])))
outfile.writelines([str(qt.tr([qt.td(p), qt.td(projectdescriptions[p])]))
                    for p in projects
                    if nstudentsbyproject[p] < int(maxperproject[p]) and len(studentsbylecturer[getlect(p)]) < int(maxperlecturer[getlect(p)])])
outfile.write('</table>\n')


# ======================================================================

# outfile.write(str(qt.h2('Choice battles')) + '\n')
# choicesbystudent = {}
# choicelist = []
# for s in students:
#      choicesbystudent[s] = [(choices[(s, p)], p) for p in projects
#                            if choices[(s, p)] in map(str, range(1,11)) and 1 <= int(choices[(s, p)]) <= 10]
#      choicelist.append([choicesbystudent[s], s])

# for c, s in sorted(choicelist):
#     print >> outfile, c,
       

# ======================================================================
#outfile.write(str(qt.h2("Project correspondence")))
#outfile.write(str(qt.p("Of the students who selected project i, what percentage also selected project j?")))
#
#def studentswhochose(p):
#    return set(s for s in students if choices[(s, p)].isdigit())
#
#chosenprojects = [p for p in projects if len(studentswhochose(p)) > 0]
#
#outfile.write("\n<table class=sortable>\n")
#outfile.write(str(qt.tr([qt.th()] + [qt.th(p) for p in chosenprojects])))
#for pi in chosenprojects:
#    studentsi = studentswhochose(pi)
#    ni = len(studentsi)
#    outfile.write("<tr>" + str(qt.th(pi)))
#    for pj in chosenprojects:
#        if ni == 0 or pi is pj:
#            print >> outfile, qt.td('-')
#        else:
#            nij = len(studentsi.intersection(studentswhochose(pj)))
#            print >> outfile, qt.td("%3i" % (100*nij/ni))
#    outfile.write("</tr>\n")
#        
#outfile.write("</table>\n")

#g = nx.Graph()
#for ((s, p), c) in choices.iteritems():
#    if c not in ('.', 'X') and float(c) < 3:
#        g.add_weighted_edges_from([(s, p, 1/float(c))])
#       
#print >> outfile, nx.connected_components(g)

outfile.write("</body></html>\n")

summ = csv.writer(open(os.path.join(outdir, 'summary.csv'), 'w'))
summ.writerow(['Student', 'Name', 'Mark', 'Project Assigned', 'Choice', 'Description'])
for s in students:
    p = projectsbystudent[s]
    summ.writerow([s, studentnames[s], marks[s], p, choices[(s, p)], projectdescriptions[p]])

#}
